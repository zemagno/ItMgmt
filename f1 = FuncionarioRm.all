f1 = FuncionarioRm.all
f0 = Funcionario.all


f_1 = Hash[FuncionarioRm.all.map { |f| [f.Login, {:demissao => f.DataDemissao, :local => f.NomeLocalTrabalho}]}]
f_0 = Hash[Funcionario.all.map { |f| [f.Login, {:demissao => f.DataDemissao, :local => f.NomeLocalTrabalho}]}]

f_1.each do |k,v|
   

end


h1.merge!(h2) { |key, v1, v2| v1 }


[f1+f0].group_by { |func| func.Login}
       .each { |Login,func| }



requests-by-ip.rb
​ 	
requests = File.open(​"data/access_log"​) ​do​ |file|
​ 	
    file
​ 	  .map { |line| { ip: line.split[0], url: line.split[5] } }
​ 	  .group_by { |request| request[:ip] }
​ 	  .each { |ip, requests| requests.map! { |r| r[:url] } }
​ 	​end​

funcRm = FuncionarioRm.all
func= Funcionario.all


# f2 = duas bases de dados de funcionarios (12115 registros)
f2 = (funcRm+func).map { |f| { login: f.Login, demissao: f.DataDemissao, local: f.NomeLocalTrabalho }}.group_by { |func| func[:login]}.each { |login, infos| infos.map! { |f| [f[:demissao], f[:local]]}}

# Contratados sao os que so constam numa base de dados, logo o group acima so retornou um valor (38)
Novos = f2.map { |k,v| {k => v} if v[1].nil? }.delete_if { |k| k.nil?}

# Retiros os contratados (12077)
f2.delete_if { |k,v|  v[1].nil? }

# Retiro os que nao mudaram nao foram demitidos nem mudaram de local (213)
f2.delete_if { |k,v|  (! v[0].nil?) and (! v[1].nil?) and  (v[0][1]==v[1][1]) && (v[0][0] == v[1][0])}

# Demitidos sao que que tem data de demissao distinta (1o campo do array) (188)
Demitidos = f2.map { |k,v| {k => v} unless v[1][0] == v[0][0] }.delete_if { |k| k.nil?}

# retiros os demitidos. (25)
Mudaram = f2.delete_if { |k,v| v[1][0] != v[0][0]}

Novos.count
Demitidos.count
Mudaram.count